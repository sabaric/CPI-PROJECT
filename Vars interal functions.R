### irf function
function (x, impulse = NULL, response = NULL, n.ahead = 10, ortho = TRUE, 
          cumulative = FALSE, boot = TRUE, ci = 0.95, runs = 100, seed = NULL, 
          ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  y.names <- colnames(x$y)
  if (is.null(impulse)) {
    impulse <- y.names
  }
  else {
    impulse <- as.vector(as.character(impulse))
    if (any(!(impulse %in% y.names))) {
      stop("\nPlease provide variables names in impulse\nthat are in the set of endogenous variables.\n")
    }
    impulse <- subset(y.names, subset = y.names %in% impulse)
  }
  if (is.null(response)) {
    response <- y.names
  }
  else {
    response <- as.vector(as.character(response))
    if (any(!(response %in% y.names))) {
      stop("\nPlease provide variables names in response\nthat are in the set of endogenous variables.\n")
    }
    response <- subset(y.names, subset = y.names %in% response)
  }
  irs <- .irf(x = x, impulse = impulse, response = response, 
              y.names = y.names, n.ahead = n.ahead, ortho = ortho, 
              cumulative = cumulative)
  Lower <- NULL
  Upper <- NULL
  if (boot) {
    ci <- as.numeric(ci)
    if ((ci <= 0) | (ci >= 1)) {
      stop("\nPlease provide a number between 0 and 1 for the confidence interval.\n")
    }
    ci <- 1 - ci
    BOOT <- .boot(x = x, n.ahead = n.ahead, runs = runs, 
                  ortho = ortho, cumulative = cumulative, impulse = impulse, 
                  response = response, ci = ci, seed = seed, y.names = y.names)
    Lower <- BOOT$Lower
    Upper <- BOOT$Upper
  }
  result <- list(irf = irs, Lower = Lower, Upper = Upper, response = response, 
                 impulse = impulse, ortho = ortho, cumulative = cumulative, 
                 runs = runs, ci = ci, boot = boot, model = class(x))
  class(result) <- "varirf"
  return(result)
}

### .irf function
function (x, impulse, response, y.names, n.ahead, ortho, cumulative) 
{
  if ((class(x) == "varest") || (class(x) == "vec2var")) {
    if (ortho) {
      irf <- Psi(x, nstep = n.ahead)
    }
    else {
      irf <- Phi(x, nstep = n.ahead)
    }
  }
  else if ((class(x) == "svarest") || (class(x) == "svecest")) {
    irf <- Phi(x, nstep = n.ahead)
  }
  dimnames(irf) <- list(y.names, y.names, NULL)
  idx <- length(impulse)
  irs <- list()
  for (i in 1:idx) {
    irs[[i]] <- matrix(t(irf[response, impulse[i], 1:(n.ahead + 
                                                        1)]), nrow = n.ahead + 1)
    colnames(irs[[i]]) <- response
    if (cumulative) {
      if (length(response) > 1) 
        irs[[i]] <- apply(irs[[i]], 2, cumsum)
      if (length(response) == 1) {
        tmp <- matrix(cumsum(irs[[1]]))
        colnames(tmp) <- response
        irs[[1]] <- tmp
      }
    }
  }
  names(irs) <- impulse
  result <- irs
  return(result)
}

###Psi Function
function (x, nstep = 10, ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  Phi <- Phi(x, nstep = nstep)
  Psi <- array(0, dim = dim(Phi))
  params <- ncol(x$datamat[, -c(1:x$K)])    # collect coefficients on endoginious vars--
  sigma.u <- crossprod(resid(x))/(x$obs - params) 
  P <- t(chol(sigma.u))
  dim3 <- dim(Phi)[3]
  for (i in 1:dim3) {
    Psi[, , i] <- Phi[, , i] %*% P
  }
  return(Psi)
}

### Phi function
function (x, nstep = 10, ...) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  nstep <- abs(as.integer(nstep))
  K <- x$K
  p <- x$p
  A <- as.array(Acoef(x))
  if (nstep >= p) {
    As <- array(0, dim = c(K, K, nstep + 1))
    for (i in (p + 1):(nstep + 1)) {
      As[, , i] <- matrix(0, nrow = K, ncol = K)
    }
  }
  else {
    As <- array(0, dim = c(K, K, p))
  }
  for (i in 1:p) {
    As[, , i] <- A[[i]]
  }
  Phi <- array(0, dim = c(K, K, nstep + 1))
  Phi[, , 1] <- diag(K)
  Phi[, , 2] <- Phi[, , 1] %*% As[, , 1]
  if (nstep > 1) {
    for (i in 3:(nstep + 1)) {
      tmp1 <- Phi[, , 1] %*% As[, , i - 1]
      tmp2 <- matrix(0, nrow = K, ncol = K)
      idx <- (i - 2):1
      for (j in 1:(i - 2)) {
        tmp2 <- tmp2 + Phi[, , j + 1] %*% As[, , idx[j]]
      }
      Phi[, , i] <- tmp1 + tmp2
    }
  }
  return(Phi)
}

#### vars:::.boot 

function (x, n.ahead, runs, ortho, cumulative, impulse, response, 
          ci, seed, y.names) 
{
  if (!(is.null(seed))) 
    set.seed(abs(as.integer(seed)))
  if (class(x) == "varest") {
    VAR <- eval.parent(x)
  }
  else if (class(x) == "svarest") {
    VAR <- eval.parent(x$var)
  }
  else {
    stop("Bootstrap not implemented for this class.\n")
  }
  p <- VAR$p
  K <- VAR$K
  obs <- VAR$obs
  total <- VAR$totobs
  type <- VAR$type
  B <- Bcoef(VAR)
  BOOT <- vector("list", runs)
  ysampled <- matrix(0, nrow = total, ncol = K)
  colnames(ysampled) <- colnames(VAR$y)
  Zdet <- NULL
  if (ncol(VAR$datamat) > (K * (p + 1))) {
    Zdet <- as.matrix(VAR$datamat[, (K * (p + 1) + 1):ncol(VAR$datamat)])
  }
  resorig <- scale(resid(VAR), scale = FALSE)
  B <- Bcoef(VAR)
  for (i in 1:runs) {
    booted <- sample(c(1:obs), replace = TRUE)
    resid <- resorig[booted, ]
    lasty <- c(t(VAR$y[p:1, ]))
    ysampled[c(1:p), ] <- VAR$y[c(1:p), ]
    for (j in 1:obs) {
      lasty <- lasty[1:(K * p)]
      Z <- c(lasty, Zdet[j, ])
      ysampled[j + p, ] <- B %*% Z + resid[j, ]
      lasty <- c(ysampled[j + p, ], lasty)
    }
    varboot <- update(VAR, y = ysampled)
    if (class(x) == "svarest") {
      varboot <- update(x, x = varboot)
    }
    BOOT[[i]] <- .irf(x = varboot, n.ahead = n.ahead, ortho = ortho, 
                      cumulative = cumulative, impulse = impulse, response = response, 
                      y.names = y.names)
  }
  lower <- ci/2
  upper <- 1 - ci/2
  mat.l <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  mat.u <- matrix(NA, nrow = n.ahead + 1, ncol = length(response))
  Lower <- list()
  Upper <- list()
  idx1 <- length(impulse)
  idx2 <- length(response)
  idx3 <- n.ahead + 1
  temp <- rep(NA, runs)
  for (j in 1:idx1) {
    for (m in 1:idx2) {
      for (l in 1:idx3) {
        for (i in 1:runs) {
          if (idx2 > 1) {
            temp[i] <- BOOT[[i]][[j]][l, m]
          }
          else {
            temp[i] <- matrix(BOOT[[i]][[j]])[l, m]
          }
        }
        mat.l[l, m] <- quantile(temp, lower, na.rm = TRUE)
        mat.u[l, m] <- quantile(temp, upper, na.rm = TRUE)
      }
    }
    colnames(mat.l) <- response
    colnames(mat.u) <- response
    Lower[[j]] <- mat.l
    Upper[[j]] <- mat.u
  }
  names(Lower) <- impulse
  names(Upper) <- impulse
  result <- list(Lower = Lower, Upper = Upper)
  return(result)
}